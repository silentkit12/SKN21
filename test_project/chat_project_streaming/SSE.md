# SSE를 이용한 streaming 채팅 구현

## 클라이언트의 요청이 없이 서버가 정보를 보내야 하는 서비스의 요구
- HTTP는 서버가 가진 웹 문서를 클라이언트가 가져오기 위해 만들어진 프로토콜이다.
    1. 클라이언트가 서버에게 요청(Request)를 보낸다.
    2. 서버가 요청받은 문서를 클라이언트에게 응답(Response) 한다.
    - 요청-응답 흐름은 항상 **클라이언트의 요청으로부터 시작된다**.
- 웹이 발전을 하면서 다음과 같은 서비스가 요구되었다.
    - 채팅 메시지 수신
    - 주식이나 코인의 실시간 가격 제공
    - 서버 모니터링 대시보드 (서버실행 로그 실시간 제공)
    - 배달이나 배송 상태 변경
- 위 서비스들은 다음과 같은 특징을 가진다.
    - 클라이언트 입장에서는 **언제 요청해야 값을 받을 수 있는지 알기 어렵다**. 
    - 값, 상태가 변경되면 즉시 클라이언트가 정보를 받아야 한다.
- 즉 **클라이언트의 요청 없이 서버가 먼저 정보를 보내줘야 한다.** 그러나 HTTP는 클라이언트의 요청이 있어야 서버가 응답을 할 수 있기 때문에 이를 위해 새로운 기법이 필요했다.
- 이에 대한 초기 해결책으로 나온 방법이 **폴링**(**Polling**) 이다. 폴링은 **클라이언트가 일정 간격으로 계속 서버에게 요청**하는 방식이다.
- **폴링의 문제점**
    - **불필요한 트래픽과 서버 부하**
        - 값의 변화가 있든 없든 주기적으로 요청하기 때문에 쓸데없는 네트워크비용, 서버 CPU, DB 조회 비용등이 늘어난다.
    - **실시간 서비스의 지연**
        - 일정 간격으로 요청하는 구조이므로 실시간이 아니라 지연된 정보를 받는 것이다. 
            - 5초 폴링이면 최대 5초 지연된 정보를 받게 된다. 
            - 간격을 줄이면 지연간격은 줄지만 부하가 더 커진다.
    - **사용자 증가에 따른 요청량이 급증**
        - 1초 폴링에 접속자가 1000명이면 초당 1000개의 요청이 주기적으로 발생한다.
- 이런 문제를 해결하기 위해 보다 근본적인 실시간 처리 방식이 필요했으며. 그 대안으로  **WebSocket**과 **SSE**(**Server-Sent Event**) 가 제안되었다.
- **WebSocket**
    - 서버와 클라이언트의 **양방향 실시간 통신**
- **SSE**(**Server-Sent Event**)
    - 서버에서 클라이언트로 **단방향 실시간 스트리밍**

## SSE(Server-Sent Events)란?

**Server-Sent Events**(**SSE**)는 **서버에서 클라이언트로 일방향으로 이벤트를 지속적으로 보내는** 웹 기술이다.   
HTTP 연결을 **한 번 맺은 후, 서버가 그 연결을 유지**하면서 새로운 데이터가 생길 때마다 클라이언트로 전송한다.


- 브라우저에서는 JavaScript의 **`EventSource` API**를 사용해 서버가 전송하는 데이터를 받는다.
- **서버에서 클라이언트에 단방향**으로 데이터를 보낸다. (클라이언트와 주고 받는 양방향 통신이 아니다. 양방향 통신이 필요한 경우 WebSocket을 사용)

### WebSocket과의 차이점

| 항목 | SSE | WebSocket |
|---|---|---|
| 통신 방향 | 단방향(서버 → 클라이언트) | 양방향(서버 ↔ 클라이언트) |
| 프로토콜 | HTTP 기반 | ws:// (별도 프로토콜) |
| 브라우저 API | `EventSource` | `WebSocket` |
| 데이터 형식 | 텍스트(UTF-8) | 텍스트 + 바이너리 |


### SSE 메시지 포맷

SSE에서 서버가 보내는 데이터가 특정 형식을 가져야 한다.

- 기본 포맷
    - `Content-Type: text/event-stream`
    - 메세지는 "data: " 로 시작한다. 메시지 단위는 **빈 줄**(**개행문자 2개**)로 구분한다. 즉 `\n\n`이 event의 끝을 표시한다.

예:
```bash
data: 안녕하세요\n\n
data: 두 번째 메시지입니다\n\n
```

여기서 `data:` 라인은 **클라이언트에서 event.data로 수신**한다.

## Django에서 SSE 응답처리 (StreamingHttpResponse 사용)

### StreamingHttpResponse
- StreamingHttpResponse는 Django에서 **응답 바디(response body)**를 한 번에 만들어서 보내는 대신, 조각(청크, chunk) 단위로 조금씩 생성해서 즉시 전송할 수 있게 해주는 응답 클래스이다.
  - **HttpResponse**: 응답 내용을 전부 만든 다음 한번에 전송한다.
  - **StreamingHttpResponse**: 서버가 응답 내용을 조금씩 만들어서(yield), 만들어지는 대로 전송한다.
- **StreamingHttpResponse의 장점**
  - 메모리 사용량 절감
    - 큰 데이터를 전송하기 위해 메모리에 한번에 올리지 않고 일부분씩 전송할 수 있다.
  - 응답을 즉시 시작할 수 있다.
    - 전체 응답 생성을 위한 처리가 끝나기 전에 **먼저 준비되는 부분부터 바로 전송**할 수 있다.
    - 시간이 오래 걸리는 작업일 경우 사용자의 대기시간을 줄여줄 수 있다.
- **사용 예**
  - SSE: 이벤트가 생길 때 마다 계속 보내야 하는 경우
  - 대용량 파일 다운로드: 파일을 통째로 메모리에 올리려면 부담이 되는 경우 일부분씩 로드해서 전송한다.
  - 서버 로그 스트리밍: 줄 단위로 계속 흘려보낼 수 있다.

#### StreamingHttpResponse 사용법
- 생성시 Iterable(Iterable, generator)을 전달 한다.
  - `StreamingHttpResponse(Iterable)`
  - Iterable이 값을 제공할 때마다 클라이언트에게 전달한다.
  - 값이 더이상 제공되지 않으면 종료한다.
- **SSE 에서 사용법**
  - `Content-Type: text/event-stream` 을 설정한다.
  - 제공하는 조각 메시지 시작은 `data: `으로 하고 끝에 `\n\n`을 붙인다.
    - `data: 메시지\n\n`

### JavaScript의 EventSource
- JavaScript가 제공하는 SSE 전용 Client API 이다.
- 서버가 보내는 실시간 이벤트를 구독 하기 위해 브라우저가 HTTP 연결을 열고 유지할 수 있게 해주는 객체이다.
- 이것을 통해 **서버에서 발생하는 변경/알림/메시지를 실시간**으로 받을 수 있다.

#### EventSource 사용법
1. 객체 생성
   - 객체 생성시 서버로 GET 요청을 보낸다.
   - `const es = new EventSource("/sse");`
2. Event Handler 등록
   - 서버에서 SSE 형식 텍스트를 보낼 때 마다 이를 받아서 처리하는 onmessage event handler를 등록한다.
   - `es.onmessage = eventHandler함수`
   - Event Handler는 서버가 보내는 데이터를 `event.data` 로 읽을 수 있다.
3. 연결 종료
   - `es.close();`